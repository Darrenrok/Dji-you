<!doctype html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=0.5,user-scalable=no">
<title>K3>_<</title>
<!-- PWA Support for better background playback -->
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiSzMgREogTWl4ZXIiLCJzaG9ydF9uYW1lIjoiSzMgREoiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzExMSIsInRoZW1lX2NvbG9yIjoiI2ZmMDA1NSJ9">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>

/* --------------  CSS identical to your last version  -------------- */
html,body{margin:0;background:#111;color:#eee;font-family:sans-serif;text-align:center}
h2{margin:.4em 0}
.waveform-full-separate{width:100%;height:80px;background:#222;position:relative;cursor:pointer;touch-action:none;margin-bottom:2px;overflow:hidden;}
canvas{width:100%;height:100%;display:block;background:#222;}
.main-content{display:flex;justify-content:center;padding:1em 0}
.decks{display:flex;justify-content:center;align-items:flex-start;gap:2em;flex-wrap:nowrap;padding:0 1em;max-width:1400px;margin:0 auto}
.deck{flex:1 1 50%;min-width:300px;max-width:none;display:flex;flex-direction:column;align-items:center}
.time-strip{width:100%;padding:4px 8px;background:#1a1a1a;border-radius:4px 4px 0 0;font-size:0.85em;color:#aaa;display:flex;justify-content:space-between;align-items:center;box-sizing:border-box;}
.time-label{font-weight:bold}
.time-code{color:#fff}
.player{width:100%;height:400px;border-radius:0 0 4px 4px;overflow:hidden}
.turntable-container{width:200px;height:200px;margin:10px 0;position:relative;border-radius:50%;background:#2a2a2a;border:8px solid #444;box-shadow:0 4px 12px rgba(0,0,0,0.5);cursor:grab;user-select:none;touch-action:none}
.turntable-container:active{cursor:grabbing}
.turntable{width:100%;height:100%;border-radius:50%;background:radial-gradient(circle, #333 30%, #222 70%);position:relative;transition:none}
.turntable.playing{animation:spin 2s linear infinite}
.turntable.dragging{animation:none !important}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
.turntable-center{position:absolute;top:50%;left:50%;width:20px;height:20px;background:#ff0055;border-radius:50%;transform:translate(-50%,-50%);z-index:2}
.turntable-line{position:absolute;top:50%;left:50%;width:2px;height:60px;background:#ff0055;transform-origin:50% 0;transform:translate(-50%,0) rotate(0deg);z-index:1}

/* Progress Ring Styles - stays inside rotating turntable */
.progress-ring{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:3;transform:rotate(-90deg)}
.progress-ring-bg{fill:none;stroke:#444;stroke-width:3}
.progress-ring-fill{fill:none;stroke:#ff0055;stroke-width:3;stroke-linecap:round;transition:stroke-dashoffset 0.1s linear}
.progress-ring-fill.deck2{stroke:#00aaff}

/* FIXED: Timecode Display - now outside rotating turntable */
.timecode-display{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Courier New',monospace;font-size:14px;font-weight:bold;color:#fff;text-shadow:0 0 4px rgba(0,0,0,0.8);z-index:10;background:rgba(0,0,0,0.8);padding:6px 10px;border-radius:4px;pointer-events:none;min-width:70px;text-align:center;letter-spacing:1px;border:1px solid rgba(255,255,255,0.3);box-shadow:0 2px 8px rgba(0,0,0,0.5)}

button{margin:.5em .3em;padding:.6em 1.8em;font-size:1.1em;color:#fff;background:#ff0055;border:none;border-radius:4px;cursor:pointer}
button:hover{background:#e60550}
.cue-loop-section{margin:10px 0;padding:10px;background:#1a1a1a;border-radius:6px;width:200px}
.cue-loop-title{font-size:0.8em;color:#aaa;font-weight:bold;margin-bottom:8px;text-align:center}
.cue-loop-controls{display:flex;flex-direction:column;gap:6px}
.cue-loop-row{display:flex;gap:4px;justify-content:center}
.cue-btn{padding:6px 8px;font-size:0.7em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s;flex:1}
.cue-btn:hover{background:#3a3a3a}
.cue-btn:active{background:#ff0055;border-color:#ff0055}
.cue-btn.active{background:#ffaa00;border-color:#ffaa00}
.loop-length-controls{display:flex;gap:2px;justify-content:center;margin-top:6px}
.loop-length-btn{padding:3px 5px;font-size:0.6em;background:#333;color:#fff;border:1px solid #555;border-radius:2px;cursor:pointer;user-select:none;transition:background 0.2s}
.loop-length-btn:hover{background:#444}
.loop-length-btn.active{background:#0a0;border-color:#0a0}
.crossfader-container{min-width:200px;display:flex;flex-direction:column;justify-content:flex-start;align-items:center;margin:2em 0}
.master-eq-section{display:flex;gap:2em;align-items:center;padding:1em;background:#1a1a1a;border-radius:8px;margin-bottom:2em}
.master-eq-title{font-size:1em;color:#aaa;font-weight:bold;margin-right:1em}
.eq-knob-group{display:flex;flex-direction:column;align-items:center}
.eq-label{font-size:0.8em;color:#aaa;margin-bottom:0.5em}
.eq-knob{width:48px;height:48px;border-radius:50%;background:#2a2a2a;border:2px solid #444;position:relative;cursor:grab;user-select:none}
.eq-knob:active{cursor:grabbing}
.eq-indicator{width:2px;height:16px;background:#ff0055;position:absolute;top:4px;left:50%;transform:translateX(-50%);transform-origin:50% 20px}
.eq-value{font-size:0.7em;color:#888;margin-top:0.3em}
.crossfader-label{font-size:0.9em;color:#aaa;margin-bottom:8px}
.crossfader-track{width:180px;height:6px;background:#444;border-radius:3px;position:relative;cursor:pointer;touch-action:none}
.crossfader-handle{width:20px;height:24px;background:#fff;border-radius:4px;position:absolute;top:-9px;left:50%;transform:translateX(-50%);cursor:grab;user-select:none;box-shadow:0 2px 6px rgba(0,0,0,0.5);z-index:10}
.crossfader-handle:active{cursor:grabbing}
.auto-mix-buttons{display:flex;gap:1em;margin-top:12px;justify-content:center}
.auto-mix-btn{padding:8px 16px;font-size:0.9em;background:#333;color:#fff;border:1px solid #555;border-radius:4px;cursor:pointer;user-select:none}
.auto-mix-btn:hover{background:#444}
.auto-mix-labels{display:flex;width:180px;justify-content:space-between;font-size:0.8em;color:#888;margin-top:8px}
.sound-effects-section{margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;width:180px}
.sound-effects-title{font-size:0.9em;color:#aaa;font-weight:bold;margin-bottom:8px;text-align:center}
.sound-effects-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px}
.fx-btn{padding:6px 8px;font-size:0.75em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s}
.fx-btn:hover{background:#3a3a3a}
.fx-btn:active{background:#ff0055;border-color:#ff0055}
.bpm-section{margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;width:180px}
.bpm-title{font-size:0.9em;color:#aaa;font-weight:bold;margin-bottom:8px;text-align:center}
.bpm-display{font-size:1.5em;color:#ff0055;text-align:center;margin-bottom:8px;font-family:monospace}
.bpm-controls{display:flex;gap:6px;justify-content:center}
.bpm-btn{padding:4px 8px;font-size:0.7em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s}
.bpm-btn:hover{background:#3a3a3a}
.bpm-btn:active{background:#ff0055;border-color:#ff0055}
.sync-status{font-size:0.7em;color:#888;text-align:center;margin-top:4px}
.playlist-section{margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;width:180px;max-height:300px;overflow-y:auto}
.playlist-title{font-size:0.9em;color:#aaa;font-weight:bold;margin-bottom:8px;text-align:center}
.playlist-track{padding:6px 8px;margin:2px 0;background:#2a2a2a;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:all 0.2s;font-size:0.7em;position:relative}
.playlist-track:hover{background:#3a3a3a}
.playlist-track.active{background:#ff0055;border-color:#ff0055;color:#fff}
.playlist-track.next-track{border-color:#ffaa00;box-shadow:0 0 8px rgba(255,170,0,0.3)}
/* FIXED: Disabled playlist track styles - NO pointer-events: none, allows scroll */
.playlist-track.disabled{opacity:0.4;background:#1a1a1a;border-color:#333;cursor:not-allowed}
.playlist-track.disabled:hover{background:#1a1a1a}
.track-assignment{display:flex;gap:4px;margin-top:8px;justify-content:center}
.assign-btn{padding:4px 8px;font-size:0.65em;background:#333;color:#fff;border:1px solid #555;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s;flex:1}
.assign-btn:hover{background:#444}
.assign-btn.deck1-active{background:#0a0;border-color:#0a0}
.assign-btn.deck2-active{background:#a00;border-color:#a00}
.add-track-btn{width:100%;padding:8px;margin-top:8px;font-size:0.7em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s}
.add-track-btn:hover{background:#3a3a3a}
.auto-mix-controls{margin-top:12px;padding:10px;background:#2a2a2a;border-radius:6px;border:1px solid #444}
.auto-mix-status{font-size:0.7em;color:#aaa;text-align:center;margin-bottom:6px}
.auto-mix-btn-row{display:flex;gap:4px;justify-content:center}
.auto-mix-small-btn{padding:4px 6px;font-size:0.6em;background:#333;color:#fff;border:1px solid #555;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s;flex:1}
.auto-mix-small-btn:hover{background:#444}
.auto-mix-small-btn.active{background:#ff0055;border-color:#ff0055}
.next-track-indicator{font-size:0.6em;color:#ffaa00;text-align:center;margin-top:4px;min-height:12px}
/* NEW: Playlist track toggle button styles */
.playlist-track-toggle{width:100%;padding:8px;margin-top:8px;font-size:0.7em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;cursor:pointer;user-select:none;transition:background 0.2s}
.playlist-track-toggle:hover{background:#3a3a3a}
.playlist-track-toggle.active{background:#ff0055;border-color:#ff0055}
.playlist-search-container{margin-bottom:8px}
.playlist-search-container input{width:100%;padding:6px;font-size:0.7em;background:#2a2a2a;color:#fff;border:1px solid #444;border-radius:3px;box-sizing:border-box}
</style>
</head>
<body>
<h2>K3>_<</h2>

<!-- FULL WIDTH, SEPARATE, FILLED WAVEFORMS -->
<div class="waveform-full-separate" id="waveWrap1"><canvas id="waveCanvas1"></canvas></div>
<div class="waveform-full-separate" id="waveWrap2"><canvas id="waveCanvas2"></canvas></div>

<!-- MAIN CONTENT ‚Äì CENTERED FLEX LAYOUT -->
<div class="main-content">
  <div class="decks">
    <!-- DECK 1 -->
    <div class="deck">
      <div class="time-strip">
        <span class="time-label">Deck 1</span>
        <span class="time-code" id="deck1Time">--:--</span>
      </div>
      <div class="turntable-container" id="turntableContainer1">
        <div class="turntable" id="turntable1">
          <div class="turntable-center"></div>
          <div class="turntable-line"></div>
          <!-- Progress ring stays inside rotating turntable -->
          <svg class="progress-ring" viewBox="0 0 100 100">
            <circle class="progress-ring-bg" cx="50" cy="50" r="46"/>
            <circle class="progress-ring-fill" id="progressRing1" cx="50" cy="50" r="46" stroke-dasharray="289.03" stroke-dashoffset="289.03"/>
          </svg>
        </div>
        <!-- FIXED: Timecode moved outside rotating turntable -->
        <div class="timecode-display" id="timecode1">00:00</div>
      </div>
      <div id="player1" class="player"></div>
      <div class="cue-loop-section">
        <div class="cue-loop-title">CUE & LOOP</div>
        <div class="cue-loop-controls">
          <div class="cue-loop-row">
            <button class="cue-btn" id="cue1Set">SET CUE</button>
            <button class="cue-btn" id="cue1Jump">JUMP CUE</button>
          </div>
          <div class="cue-loop-row">
            <button class="cue-btn" id="loop1In">LOOP IN</button>
            <button class="cue-btn" id="loop1Out">LOOP OUT</button>
          </div>
          <div class="cue-loop-row">
            <button class="cue-btn" id="loop1Active">LOOP ON</button>
            <button class="cue-btn" id="cue1Clear">CLEAR</button>
          </div>
          <div class="loop-length-controls">
            <button class="loop-length-btn" data-deck="1" data-length="4">4</button>
            <button class="loop-length-btn" data-deck="1" data-length="8">8</button>
            <button class="loop-length-btn" data-deck="1" data-length="16">16</button>
            <button class="loop-length-btn" data-deck="1" data-length="32">32</button>
          </div>
        </div>
      </div>
      <button id="playBtn1">‚ñ∂ PLAY</button>
    </div>

    <!-- CROSSFADER + MASTER EQ + EFFECTS ‚Äì CENTERED BLOCK -->
    <div class="crossfader-container">
      <div class="master-eq-section">
        <div class="eq-knob-group">
          <div class="eq-label">LOW</div>
          <div class="eq-knob" id="master-low" data-filter="low"><div class="eq-indicator"></div></div>
          <div class="eq-value" id="master-low-value">0dB</div>
        </div>
        <div class="eq-knob-group">
          <div class="eq-label">MID</div>
          <div class="eq-knob" id="master-mid" data-filter="mid"><div class="eq-indicator"></div></div>
          <div class="eq-value" id="master-mid-value">0dB</div>
        </div>
        <div class="eq-knob-group">
          <div class="eq-label">HIGH</div>
          <div class="eq-knob" id="master-high" data-filter="high"><div class="eq-indicator"></div></div>
          <div class="eq-value" id="master-high-value">0dB</div>
        </div>
      </div>
      <div class="crossfader-label">CROSSFADER</div>
      <div class="crossfader-track" id="crossfaderTrack">
        <div class="crossfader-handle" id="crossfaderHandle"></div>
      </div>
      <div class="auto-mix-buttons">
        <button class="auto-mix-btn" id="autoMixLeft">‚Üê Auto Mix</button>
        <button class="auto-mix-btn" id="autoMixRight">Auto Mix ‚Üí</button>
      </div>
      <div class="auto-mix-labels"><span>Deck 1</span><span>Deck 2</span></div>
      <div class="auto-mix-controls">
        <div class="auto-mix-status" id="autoMixStatus">Auto-Mix: OFF</div>
        <div class="auto-mix-btn-row">
          <button class="auto-mix-small-btn" id="autoMixToggle">ENABLE</button>
          <button class="auto-mix-small-btn" id="nextTrackBtn">NEXT</button>
        </div>
        <div class="next-track-indicator" id="nextTrackIndicator"></div>
      </div>

      <!-- Playlist -->
      <div class="playlist-search-container">
        <input type="text" id="playlistSearch" placeholder="Search playlist..." style="background-color:black;color:white;">
      </div>

      <div class="playlist-section" id="playlistSection">
        <div class="playlist-title">PLAYLIST</div>
        <div id="playlistContainer"></div>
        <button hidden class="add-track-btn" id="addTrackBtn">+ ADD TRACK</button>
      
      </div>
         <!-- NEW: Toggle button for enabling/disabling playlist tracks -->
        <button class="playlist-track-toggle" id="playlistTrackToggle">üö´ DISABLE TRACKS</button>
      <div class="track-assignment">
        <button class="assign-btn" id="assignDeck1">DECK 1</button>
        <button class="assign-btn" id="assignDeck2">DECK 2</button>
      </div>

      <div class="bpm-section">
        <div class="bpm-title">BPM SYNC</div>
        <div class="bpm-display" id="bpmDisplay">120.0</div>
        <div class="bpm-controls">
          <button class="bpm-btn" id="tapTempo1">TAP DECK 1</button>
          <button class="bpm-btn" id="tapTempo2">TAP DECK 2</button>
        </div>
        <div class="bpm-controls">
          <button class="bpm-btn" id="syncBPM">SYNC BPM</button>
          <button class="bpm-btn" id="resetBPM">RESET</button>
        </div>
        <div class="sync-status" id="syncStatus">Manual Mode</div>
      </div>
      <div class="sound-effects-section">
        <div class="sound-effects-title">SOUND FX</div>
        <div class="sound-effects-grid">
          <button class="fx-btn" id="fxEcho">Echo</button>
          <button class="fx-btn" id="fxReverb">Reverb</button>
          <button class="fx-btn" id="fxFilter">Filter</button>
          <button class="fx-btn" id="fxFlanger">Flanger</button>
          <button class="fx-btn" id="fxDistort">Distort</button>
          <button class="fx-btn" id="fxGate">Gate</button>
          <button class="fx-btn" id="fxPhaser">Phaser</button>
          <button class="fx-btn" id="fxChop">Chop</button>
        </div>
      </div>
    </div>

    <!-- DECK 2 -->
    <div class="deck">
      <div class="time-strip">
        <span class="time-label">Deck 2</span>
        <span class="time-code" id="deck2Time">--:--</span>
      </div>
      <div class="turntable-container" id="turntableContainer2">
        <div class="turntable" id="turntable2">
          <div class="turntable-center"></div>
          <div class="turntable-line"></div>
          <!-- Progress ring stays inside rotating turntable -->
          <svg class="progress-ring" viewBox="0 0 100 100">
            <circle class="progress-ring-bg" cx="50" cy="50" r="46"/>
            <circle class="progress-ring-fill deck2" id="progressRing2" cx="50" cy="50" r="46" stroke-dasharray="289.03" stroke-dashoffset="289.03"/>
          </svg>
        </div>
        <!-- FIXED: Timecode moved outside rotating turntable -->
        <div class="timecode-display" id="timecode2">00:00</div>
      </div>
      <div id="player2" class="player"></div>
      <div class="cue-loop-section">
        <div class="cue-loop-title">CUE & LOOP</div>
        <div class="cue-loop-controls">
          <div class="cue-loop-row">
            <button class="cue-btn" id="cue2Set">SET CUE</button>
            <button class="cue-btn" id="cue2Jump">JUMP CUE</button>
          </div>
          <div class="cue-loop-row">
            <button class="cue-btn" id="loop2In">LOOP IN</button>
            <button class="cue-btn" id="loop2Out">LOOP OUT</button>
          </div>
          <div class="cue-loop-row">
            <button class="cue-btn" id="loop2Active">LOOP ON</button>
            <button class="cue-btn" id="cue2Clear">CLEAR</button>
          </div>
          <div class="loop-length-controls">
            <button class="loop-length-btn" data-deck="2" data-length="4">4</button>
            <button class="loop-length-btn" data-deck="2" data-length="8">8</button>
            <button class="loop-length-btn" data-deck="2" data-length="16">16</button>
            <button class="loop-length-btn" data-deck="2" data-length="32">32</button>
          </div>
        </div>
      </div>
      <button id="playBtn2">‚ñ∂ PLAY</button>
    </div>
  </div>
</div>

<script>
//get playlist
 let playlist;
fetch('https://raw.githubusercontent.com/Darrenrok/Dji-you/refs/heads/main/mix.json')
  .then(response => {
    if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(jsonData => {
    playlist=jsonData
	renderPlaylist();
    // Work with the jsonData object
  })
  .catch(error => {
    console.error('Error fetching JSON:', error);
	alert('Error fetching JSON DATA')
  });
/* ==========  ALL GLOBALS (identical to your last version) ========== */
const $ = id => document.getElementById(id);
let videoId1 = 'M7lc1UVf-VE';
let videoId2 = 'dQw4w9WgXcQ';
let ytPlayer1 = null, ytPlayer2 = null;
let crossfaderPos = 0.5;
let autoFadeAnimation = null;

const EQ_SETTINGS = { low: { freq: 320, type: 'lowshelf' }, mid: { freq: 1000, type: 'peaking' }, high: { freq: 3200, type: 'highshelf' } };
const masterEQFilters = {};
let masterCtx = null;

let fxCtx = null, fxMasterGain = null;

/* --------------  NEW SCRATCH STATE  -------------- */
const scratchState = {
  1: { dragging: false, lastAngle: 0, lastTime: 0, velocity: 0, inertia: null },
  2: { dragging: false, lastAngle: 0, lastTime: 0, velocity: 0, inertia: null }
};

/* turntableStates now only keeps rotation for visuals */
let turntableStates = { 1: { rotation: 0 }, 2: { rotation: 0 } };

/* BPM, playlist, auto-mix, cue-loop ‚Ä¶ unchanged */
let bpmData = { deck1: { taps: [], bpm: 120, lastTap: 0 }, deck2: { taps: [], bpm: 120, lastTap: 0 }, masterBPM: 120, isSynced: false };
////////////////////////

/////////////////////////////
 let currentPlaylistIndex = 0, currentAssignment = 1;
let autoMixEnabled = false, autoMixTimeout = null, isAutoMixing = false;
let resizeTimeout = null, isResizing = false;
let cueLoopData = { 1: { cuePoint: null, loopIn: null, loopOut: null, loopActive: false, autoLoopLength: 8, isLooping: false }, 2: { cuePoint: null, loopIn: null, loopOut: null, loopActive: false, autoLoopLength: 8, isLooping: false } };

/* NEW: Playlist tracks enabled/disabled state */
let playlistTracksEnabled = true;

/* ==========  HELPERS (unchanged) ========== */
function safeGetDuration(player) { if (!player || typeof player.getDuration !== 'function') return 0; try { const d = player.getDuration(); return (typeof d === 'number' && d > 0) ? d : 0; } catch (e) { return 0; } }
function safeGetCurrentTime(player) { if (!player || typeof player.getCurrentTime !== 'function') return 0; try { const t = player.getCurrentTime(); return (typeof t === 'number' && t >= 0) ? t : 0; } catch (e) { return 0; } }
function safeSeek(player, sec) { if (!player || typeof player.seekTo !== 'function') return; try { const dur = safeGetDuration(player); if (dur > 0 && sec >= 0 && sec <= dur) player.seekTo(sec, true); } catch (e) { /* ignore */ } }
function safeIsPlaying(player) { if (!player || typeof player.getPlayerState !== 'function') return false; try { return player.getPlayerState() === YT.PlayerState.PLAYING; } catch (e) { return false; } }
function safeSetVolume(player, vol) { if (!player || typeof player.setVolume !== 'function') return; try { player.setVolume(Math.max(0, Math.min(100, vol))); } catch (e) { /* ignore */ } }

/* ==========  NEW SCRATCH UTILS  ========== */
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function angleDiff(a, b) { let d = a - b; while (d > 180) d -= 360; while (d < -180) d += 360; return d; }

/* ----------  physical scratch control  ---------- */
function doScratch(deckNum, angle) {
  const st = scratchState[deckNum];
  const now = performance.now();
  const player = deckNum === 1 ? ytPlayer1 : ytPlayer2;
  if (!player) return;

  const da = angleDiff(angle, st.lastAngle);
  const dt = now - st.lastTime;
  st.velocity = dt ? da / dt * 1000 : 0; // deg/sec
  st.lastAngle = angle;
  st.lastTime = now;

  const dur = safeGetDuration(player);
  if (dur === 0) return;
  const currentTime = safeGetCurrentTime(player);
  const newTime = clamp(currentTime + da / 360 * dur, 0, dur);
  safeSeek(player, newTime);

  /* mute while scratching (classic vinyl behaviour) */
  safeSetVolume(player, 0);
}

/* ----------  inertia after release  ---------- */
function releaseScratch(deckNum) {
  const st = scratchState[deckNum];
  const player = deckNum === 1 ? ytPlayer1 : ytPlayer2;
  if (!player) return;

  if (st.inertia) cancelAnimationFrame(st.inertia);
  let v = st.velocity * 0.8; // initial coast speed
  const decay = 0.95; // friction

  function coast() {
    if (Math.abs(v) < 0.5) { /* stopped */
      safeSetVolume(player, 100);
      st.velocity = 0;
      return;
    }
    const dur = safeGetDuration(player);
    const currentTime = safeGetCurrentTime(player);
    const advance = v / 360 * dur / 60; // rough: 60 fps
    safeSeek(player, clamp(currentTime + advance, 0, dur));
    v *= decay;
    st.inertia = requestAnimationFrame(coast);
  }
  coast();
}

/* ==========  TURNTABLE INTERACTION (re-written for scratch)  ========== */
function setupTurntableInteraction(deckNum) {
  const container = $(`turntableContainer${deckNum}`);
  const turntable = $(`turntable${deckNum}`);
  const st = scratchState[deckNum];

  function getAngle(e) {
    const rect = container.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left - rect.width / 2;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top - rect.height / 2;
    return Math.atan2(y, x) * 180 / Math.PI;
  }

  function onStart(e) {
    st.dragging = true;
    st.lastAngle = getAngle(e);
    st.lastTime = performance.now();
    turntable.classList.add('dragging');
    turntable.classList.remove('playing');
    if (st.inertia) cancelAnimationFrame(st.inertia);
    e.preventDefault();
  }

  function onMove(e) {
    if (!st.dragging) return;
    const angle = getAngle(e);
    doScratch(deckNum, angle);
    /* visual rotation */
    turntableStates[deckNum].rotation = angle;
    turntable.style.transform = `rotate(${angle}deg)`;
    e.preventDefault();
  }

  function onEnd(e) {
    if (!st.dragging) return;
    st.dragging = false;
    turntable.classList.remove('dragging');
    releaseScratch(deckNum);
    e.preventDefault();
  }

  /* mouse */
  container.addEventListener('mousedown', onStart);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onEnd);
  /* touch */
  container.addEventListener('pointerdown', onStart, { passive: false });
  window.addEventListener('touchmove', onMove, { passive: false });
  window.addEventListener('touchend', onEnd, { passive: false });
}

/* ==========  REST OF FILE (unchanged except tiny hooks)  ========== */
/* cue/loop section identical */
function setCuePoint(deckNum) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (!player) return; cueLoopData[deckNum].cuePoint = safeGetCurrentTime(player); flashBtn(`cue${deckNum}Set`, 'CUE SET', 500); }
function jumpToCuePoint(deckNum) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (!player || cueLoopData[deckNum].cuePoint === null) return; safeSeek(player, cueLoopData[deckNum].cuePoint); flashBtn(`cue${deckNum}Jump`, '', 300); }
function flashBtn(id, text, ms) { const b = $(id); if (text) b.textContent = text; b.style.background = '#ffaa00'; setTimeout(() => { b.style.background = ''; if (text) b.textContent = id.includes('Set') ? 'SET CUE' : 'JUMP CUE'; }, ms); }
function setLoopIn(deckNum) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (!player) return; cueLoopData[deckNum].loopIn = safeGetCurrentTime(player); flashBtn(`loop${deckNum}In`, '', 500); }
function setLoopOut(deckNum) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (!player || cueLoopData[deckNum].loopIn === null) return; const t = safeGetCurrentTime(player); if (t <= cueLoopData[deckNum].loopIn) { alert('Loop OUT must be after Loop IN'); return; } cueLoopData[deckNum].loopOut = t; cueLoopData[deckNum].loopActive = true; updateLoopButtonStates(deckNum); }
function toggleLoop(deckNum) { const d = cueLoopData[deckNum]; if (!d.loopIn) { alert('Set Loop IN first'); return; } if (!d.loopOut) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (player) { const dur = safeGetDuration(player); d.loopOut = Math.min(d.loopIn + d.autoLoopLength, dur); d.loopActive = true; } } else { d.loopActive = !d.loopActive; } updateLoopButtonStates(deckNum); if (d.loopActive) startLoopMonitoring(deckNum); }
function updateLoopButtonStates(deckNum) { const d = cueLoopData[deckNum]; const b = $(`loop${deckNum}Active`); b.textContent = d.loopActive ? 'LOOP OFF' : 'LOOP ON'; b.classList.toggle('active', d.loopActive); }
function clearCueLoop(deckNum) { cueLoopData[deckNum] = { cuePoint: null, loopIn: null, loopOut: null, loopActive: false, autoLoopLength: cueLoopData[deckNum].autoLoopLength, isLooping: false }; updateLoopButtonStates(deckNum); flashBtn(`cue${deckNum}Clear`, '', 300); }
function startLoopMonitoring(deckNum) { const player = deckNum === 1 ? ytPlayer1 : ytPlayer2; if (!player) return; function check() { const d = cueLoopData[deckNum]; if (!d.loopActive || !d.loopIn || !d.loopOut) return; if (safeGetCurrentTime(player) >= d.loopOut) safeSeek(player, d.loopIn); requestAnimationFrame(check); } check(); }

/* auto-mix identical */
function toggleAutoMix() { autoMixEnabled = !autoMixEnabled; const b = $('autoMixToggle'), s = $('autoMixStatus'); b.classList.toggle('active', autoMixEnabled); b.textContent = autoMixEnabled ? 'DISABLE' : 'ENABLE'; s.textContent = autoMixEnabled ? 'Auto-Mix: ON' : 'Auto-Mix: OFF'; autoMixEnabled ? startAutoMixMonitoring() : stopAutoMixMonitoring(); }
function startAutoMixMonitoring() { if (!autoMixEnabled) return; checkTrackStatus(); }
function stopAutoMixMonitoring() { if (autoMixTimeout) clearTimeout(autoMixTimeout); $('nextTrackIndicator').textContent = ''; }
function checkTrackStatus() { if (!autoMixEnabled) return; const dur1 = safeGetDuration(ytPlayer1), time1 = safeGetCurrentTime(ytPlayer1), dur2 = safeGetDuration(ytPlayer2), time2 = safeGetCurrentTime(ytPlayer2), rem1 = dur1 - time1, rem2 = dur2 - time2; if (rem1 > 0 && rem1 < 10 && safeIsPlaying(ytPlayer1)) prepareNextTrack(2); else if (rem2 > 0 && rem2 < 10 && safeIsPlaying(ytPlayer2)) prepareNextTrack(1); if (autoMixEnabled) autoMixTimeout = setTimeout(checkTrackStatus, 1000); }
function prepareNextTrack(targetDeck) { const t = getNextTrack(); if (!t) return; $('nextTrackIndicator').textContent = `Next: ${t.title} (${t.bpm} BPM) ‚Üí Deck ${targetDeck}`; highlightNextTrack(t); const rem = (targetDeck === 1 ? safeGetDuration(ytPlayer2) : safeGetDuration(ytPlayer1)) - (targetDeck === 1 ? safeGetCurrentTime(ytPlayer2) : safeGetCurrentTime(ytPlayer1)); setTimeout(() => loadAndPlayNext(t, targetDeck), Math.max(0, (rem - 3) * 1000)); }
function manualNextTrack() { if (isAutoMixing) return; const t = getNextTrack(); if (!t) return; const p1 = safeIsPlaying(ytPlayer1), p2 = safeIsPlaying(ytPlayer2); let target = !p1 && p2 ? 1 : p1 && !p2 ? 2 : !p1 && !p2 ? 1 : (safeGetDuration(ytPlayer1) - safeGetCurrentTime(ytPlayer1) < safeGetDuration(ytPlayer2) - safeGetCurrentTime(ytPlayer2) ? 1 : 2); loadAndPlayNext(t, target); }
function loadAndPlayNext(track, targetDeck) { if (!autoMixEnabled && !isAutoMixing) return; isAutoMixing = true; console.log(`Auto-mix: Loading ${track.title} to Deck ${targetDeck}`); loadTrackToDeck(track, targetDeck); setTimeout(() => { const p = targetDeck === 1 ? ytPlayer1 : ytPlayer2; if (p) p.playVideo(); }, 1500); setTimeout(() => { if (Math.abs(bpmData.deck1.bpm - bpmData.deck2.bpm) > 2) syncBPM(); }, 2000); setTimeout(() => { autoFadeTo(targetDeck === 1 ? 0.3 : 0.7, 2000); isAutoMixing = false; }, 3000); $('nextTrackIndicator').textContent = ''; }
function getNextTrack() { if (playlist.length === 0) return null; currentPlaylistIndex = (currentPlaylistIndex + 1) % playlist.length; return playlist[currentPlaylistIndex]; }
function highlightNextTrack(track) { document.querySelectorAll('.playlist-track').forEach(el => el.classList.remove('next-track')); const els = document.querySelectorAll('.playlist-track'); const idx = (currentPlaylistIndex + 1) % playlist.length; if (els[idx]) els[idx].classList.add('next-track'); }

/* playlist functions */
function loadTrackToDeck(track, deckNum) { 
  // Don't load if tracks are disabled
  if (!playlistTracksEnabled) return;
  
  const el = document.querySelectorAll('.playlist-track')[playlist.findIndex(t => t.id === track.id)]; 
  if (el) el.classList.add('loading'); 
  if (deckNum === 1) { videoId1 = track.id; if (ytPlayer1) ytPlayer1.loadVideoById(track.id); bpmData.deck1.bpm = track.bpm;  ytplayer1_playing=1;ytplayer2_playing=0;} else { videoId2 = track.id; if (ytPlayer2) ytPlayer2.loadVideoById(track.id); bpmData.deck2.bpm = track.bpm;  ytplayer1_playing=0;ytplayer2_playing=1;} 
  renderPlaylist(); 
  if (Math.abs(bpmData.deck1.bpm - bpmData.deck2.bpm) > 2) setTimeout(syncBPM, 1000); 
}
function addNewTrack() { const pool = [ { id: '9bZkp7q19f0', title: 'New Track A', bpm: 118 }, { id: 'kXYiU_JCYtU', title: 'New Track B', bpm: 132 }, { id: 'uelHwf8o7_Gk', title: 'New Track C', bpm: 126 }, { id: 'RgKAFK5djSk', title: 'New Track D', bpm: 124 } ]; const t = pool[Math.floor(Math.random() * pool.length)]; playlist.push(t); renderPlaylist(); }
function updateAssignmentButtons() { $('assignDeck1').classList.toggle('deck1-active', currentAssignment === 1); $('assignDeck2').classList.toggle('deck2-active', currentAssignment === 2); }

/* renderPlaylist with data attributes */
function renderPlaylist() {
  const c = $('playlistContainer');
  c.innerHTML = '';
  playlist.forEach((t, i) => {
    const div = document.createElement('div');
    div.className = 'playlist-track';
    
    // Add disabled class if tracks are disabled
    if (!playlistTracksEnabled) {
      div.classList.add('disabled');
    }
    
    div.setAttribute('data-title', t.title);
    div.setAttribute('data-bpm', t.bpm);
    div.setAttribute('data-genre', t.genre || '');
    div.innerHTML = `${t.title}<span class="bpm-tag">${t.bpm} BPM</span>`;
    
    if (t.id === videoId1 || t.id === videoId2) div.classList.add('active');
    if (autoMixEnabled && i === ((currentPlaylistIndex + 1) % playlist.length)) div.classList.add('next-track');
    
    // Only add event listener if tracks are enabled
    if (playlistTracksEnabled) {
      div.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent scroll when clicking
        loadTrackToDeck(t, currentAssignment);
      }, { passive: false });
    }
    
    c.appendChild(div);
  });
}

/* NEW: Playlist filter function */
function filterPlaylist() {
  const searchTerm = $('playlistSearch').value.toLowerCase();
  const tracks = document.querySelectorAll('.playlist-track');
  
  tracks.forEach(track => {
    const trackText = track.textContent.toLowerCase();
    const title = track.getAttribute('data-title') || '';
    const bpm = track.getAttribute('data-bpm') || '';
    const genre = track.getAttribute('data-genre') || '';
    
    const matchesSearch = trackText.includes(searchTerm) || 
                         title.toLowerCase().includes(searchTerm) ||
                         bpm.includes(searchTerm) ||
                         genre.toLowerCase().includes(searchTerm);
    
    track.style.display = matchesSearch ? 'block' : 'none';
  });
}

/* NEW: Toggle playlist tracks enabled/disabled */
function togglePlaylistTracks() {
  playlistTracksEnabled = !playlistTracksEnabled;
  const btn = $('playlistTrackToggle');
  
  btn.classList.toggle('active', !playlistTracksEnabled);
  
  if (playlistTracksEnabled) {
    btn.textContent = 'üö´ DISABLE TRACKS';
    btn.title = 'Click to disable playlist track selection';
  } else {
    btn.textContent = '‚úÖ ENABLE TRACKS';
    btn.title = 'Click to enable playlist track selection';
  }
  
  // Re-render playlist to apply changes
  renderPlaylist();
}

/* resize identical */
function handleResize() { if (resizeTimeout) clearTimeout(resizeTimeout); isResizing = true; resizeCanvases(); resizeTimeout = setTimeout(() => { redrawWaveforms(); isResizing = false; }, 150); }
function resizeCanvases() { ['waveCanvas1', 'waveCanvas2'].forEach(id => { const c = $(id), r = c.getBoundingClientRect(), dpr = window.devicePixelRatio || 1; c.width = Math.round(r.width * dpr); c.height = Math.round(r.height * dpr); c.style.width = r.width + 'px'; c.style.height = r.height + 'px'; c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0); }); }
function redrawWaveforms() { ['waveCanvas1', 'waveCanvas2'].forEach((id, i) => { const c = $(id), player = i === 0 ? ytPlayer1 : ytPlayer2; buildRandomPeaks(c); const dur = safeGetDuration(player), time = safeGetCurrentTime(player); if (dur > 0 && time >= 0) drawWaveform(c, time / dur, i === 0 ? '#0f0' : '#f00', i === 1); }); }

/* BPM identical */
function calculateBPM(taps) { if (taps.length < 2) return 120; let intervals = []; for (let i = 1; i < taps.length; i++) intervals.push(taps[i] - taps[i - 1]); const avg = intervals.reduce((a, b) => a + b, 0) / intervals.length; return Math.round(60000 / avg); }
function tapTempo(deckNum) { const now = Date.now(), d = bpmData[`deck${deckNum}`]; if (now - d.lastTap > 2000) d.taps = []; d.taps.push(now); d.lastTap = now; if (d.taps.length > 8) d.taps.shift(); if (d.taps.length >= 2) { d.bpm = calculateBPM(d.taps); updateBPMDisplay(); updateSyncStatus(`Deck ${deckNum}: ${d.bpm} BPM`); } }
function syncBPM() { const avg = Math.round((bpmData.deck1.bpm + bpmData.deck2.bpm) / 2); bpmData.masterBPM = avg; bpmData.deck1.bpm = avg; bpmData.deck2.bpm = avg; bpmData.isSynced = true; updateBPMDisplay(); updateSyncStatus(`SYNCED: ${avg} BPM`); centerCrossfader(); }
function resetBPM() { bpmData.deck1.bpm = 120; bpmData.deck2.bpm = 120; bpmData.masterBPM = 120; bpmData.isSynced = false; bpmData.deck1.taps = []; bpmData.deck2.taps = []; updateBPMDisplay(); updateSyncStatus('Manual Mode'); }
function updateBPMDisplay() { $('bpmDisplay').textContent = bpmData.masterBPM.toFixed(1); }
function updateSyncStatus(s) { $('syncStatus').textContent = s; }
function centerCrossfader() { crossfaderPos = 0.5; $('crossfaderHandle').style.left = '50%'; updateVolumes(); }

/* master EQ identical */
function addMasterEQControls() { const knobs = document.querySelectorAll('.eq-knob'); const maxRot = 135, cur = { low: 0, mid: 0, high: 0 }; knobs.forEach(k => { let drag = false, startY = 0; const band = k.dataset.filter, ind = k.querySelector('.eq-indicator'), val = $(`master-${band}-value`); k.style.transform = `rotate(${cur[band]}deg)`; function update(y) { const delta = startY - y, sens = 0.5; cur[band] = clamp(cur[band] + delta * sens, -maxRot, maxRot); k.style.transform = `rotate(${cur[band]}deg)`; const gain = (cur[band] / maxRot) * 12; val.textContent = `${gain.toFixed(1)}dB`; if (masterEQFilters[band]) masterEQFilters[band].gain.value = gain; startY = y; } k.addEventListener('mousedown', e => { drag = true; startY = e.clientY; e.preventDefault(); }); window.addEventListener('mousemove', e => { if (!drag) return; update(e.clientY); e.preventDefault(); }); window.addEventListener('mouseup', () => drag = false); k.addEventListener('pointerdown', e => { drag = true; startY = e.touches[0].clientY; e.preventDefault(); }, { passive: false }); window.addEventListener('touchmove', e => { if (!drag) return; update(e.touches[0].clientY); e.preventDefault(); }, { passive: false }); window.addEventListener('touchend', () => drag = false); }); }

/* crossfader identical */
function updateVolumes() { if (!ytPlayer1 || !ytPlayer2) return; safeSetVolume(ytPlayer1, Math.max(0, Math.min(100, (1 - crossfaderPos) * 100))); safeSetVolume(ytPlayer2, Math.max(0, Math.min(100, crossfaderPos * 100))); }
function autoFadeTo(target, dur = 2000) { if (autoFadeAnimation) cancelAnimationFrame(autoFadeAnimation); const start = crossfaderPos, startTime = performance.now(), delta = target - start; function animate(t) { const prog = Math.min((t - startTime) / dur, 1), eased = prog < 0.5 ? 2 * prog * prog : 1 - Math.pow(-2 * prog + 2, 2) / 2; crossfaderPos = start + delta * eased; $('crossfaderHandle').style.left = (crossfaderPos * 100) + '%'; updateVolumes(); if (prog < 1) autoFadeAnimation = requestAnimationFrame(animate); else autoFadeAnimation = null; } animate(performance.now()); }
function setupCrossfader() { const track = $('crossfaderTrack'), handle = $('crossfaderHandle'); let drag = false; function update(x) { const rect = track.getBoundingClientRect(); x = clamp(x, 0, rect.width); crossfaderPos = x / rect.width; handle.style.left = (crossfaderPos * 100) + '%'; updateVolumes(); } track.addEventListener('mousedown', e => { drag = true; update(e.clientX - track.getBoundingClientRect().left); }); window.addEventListener('mousemove', e => { if (!drag) return; update(e.clientX - track.getBoundingClientRect().left); }); window.addEventListener('mouseup', () => drag = false); track.addEventListener('pointerdown', e => { drag = true; update(e.touches[0].clientX - track.getBoundingClientRect().left); e.preventDefault(); }, { passive: false }); window.addEventListener('touchmove', e => { if (!drag) return; update(e.touches[0].clientX - track.getBoundingClientRect().left); e.preventDefault(); }, { passive: false }); window.addEventListener('touchend', () => drag = false); }

/* waveform touch identical */
function addSeparateTouchControls() { const w1 = $('waveWrap1'), w2 = $('waveWrap2'); function add(w, player, rev) { function scrub(e) { const dur = safeGetDuration(player); if (!dur) return; const rect = w.getBoundingClientRect(); let r = ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) / rect.width; if (rev) r = 1 - r; safeSeek(player, clamp(r, 0, 1) * dur); } w.addEventListener('mousedown', e => { w.dragging = true; scrub(e); }); w.addEventListener('pointerdown', e => { w.dragging = true; scrub(e.touches[0]); e.preventDefault(); }, { passive: false }); } add(w1, ytPlayer1, false); add(w2, ytPlayer2, true); window.addEventListener('mousemove', e => { if (w1.dragging) { const dur = safeGetDuration(ytPlayer1); if (!dur) return; const rect = w1.getBoundingClientRect(); let r = (e.clientX - rect.left) / rect.width; safeSeek(ytPlayer1, clamp(r, 0, 1) * dur); } if (w2.dragging) { const dur = safeGetDuration(ytPlayer2); if (!dur) return; const rect = w2.getBoundingClientRect(); let r = 1 - ((e.clientX - rect.left) / rect.width); safeSeek(ytPlayer2, clamp(r, 0, 1) * dur); } }); window.addEventListener('mouseup', () => { w1.dragging = false; w2.dragging = false; }); window.addEventListener('touchmove', e => { if (w1.dragging) { const dur = safeGetDuration(ytPlayer1); if (!dur) return; const rect = w1.getBoundingClientRect(); let r = (e.touches[0].clientX - rect.left) / rect.width; safeSeek(ytPlayer1, clamp(r, 0, 1) * dur); } if (w2.dragging) { const dur = safeGetDuration(ytPlayer2); if (!dur) return; const rect = w2.getBoundingClientRect(); let r = 1 - ((e.touches[0].clientX - rect.left) / rect.width); safeSeek(ytPlayer2, clamp(r, 0, 1) * dur); } e.preventDefault(); }, { passive: false }); window.addEventListener('touchend', () => { w1.dragging = false; w2.dragging = false; }); }

/* FX identical */
function initSoundEffects() { if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') { console.warn('Web Audio API not supported'); return null; } fxCtx = new (window.AudioContext || window.webkitAudioContext)(); fxMasterGain = fxCtx.createGain(); fxMasterGain.gain.value = 0.3; fxMasterGain.connect(fxCtx.destination); }
function createEcho() { if (!fxCtx) return null; const delay = fxCtx.createDelay(), feedback = fxCtx.createGain(), wet = fxCtx.createGain(); delay.delayTime.value = 0.3; feedback.gain.value = 0.4; wet.gain.value = 0.5; delay.connect(feedback); feedback.connect(delay); delay.connect(wet); wet.connect(fxMasterGain); return { delay, feedback, wet }; }
function createReverb() { if (!fxCtx) return null; const conv = fxCtx.createConvolver(), len = fxCtx.sampleRate * 2, impulse = fxCtx.createBuffer(2, len, fxCtx.sampleRate); for (let c = 0; c < 2; c++) { const d = impulse.getChannelData(c); for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2); } conv.buffer = impulse; const wet = fxCtx.createGain(); wet.gain.value = 0.4; conv.connect(wet); wet.connect(fxMasterGain); return { convolver: conv, wet }; }
function createFilter() { if (!fxCtx) return null; const f = fxCtx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 1000; f.Q.value = 5; const wet = fxCtx.createGain(); wet.gain.value = 0.6; f.connect(wet); wet.connect(fxMasterGain); return { filter: f, wet }; }
function createFlanger() { if (!fxCtx) return null; const delay = fxCtx.createDelay(), lfo = fxCtx.createOscillator(), lfoGain = fxCtx.createGain(), wet = fxCtx.createGain(); delay.delayTime.value = 0.005; lfo.frequency.value = 0.5; lfoGain.gain.value = 0.002; wet.gain.value = 0.5; lfo.connect(lfoGain); lfoGain.connect(delay.delayTime); delay.connect(wet); wet.connect(fxMasterGain); lfo.start(); return { delay, lfo, lfoGain, wet }; }
function createDistortion() { if (!fxCtx) return null; const w = fxCtx.createWaveShaper(), amount = 50, samples = 44100, curve = new Float32Array(samples); for (let i = 0; i < samples; i++) { const x = (i * 2) / samples - 1; curve[i] = ((3 + amount) * x * 20 * Math.PI / 180) / (Math.PI + amount * Math.abs(x)); } w.curve = curve; const wet = fxCtx.createGain(); wet.gain.value = 0.3; w.connect(wet); wet.connect(fxMasterGain); return { waveshaper: w, wet }; }
function createGate() { if (!fxCtx) return null; const g = fxCtx.createGain(), lfo = fxCtx.createOscillator(), lfoGain = fxCtx.createGain(); lfo.frequency.value = 4; lfoGain.gain.value = 0.8; lfo.connect(lfoGain); lfoGain.connect(g.gain); g.connect(fxMasterGain); lfo.start(); return { gate: g, lfo, lfoGain }; }
function createPhaser() { if (!fxCtx) return null; const input = fxCtx.createGain(), output = fxCtx.createGain(), stages = 6, filters = []; for (let i = 0; i < stages; i++) { const f = fxCtx.createBiquadFilter(); f.type = 'allpass'; f.frequency.value = 800 + i * 200; filters.push(f); if (i === 0) input.connect(f); else filters[i - 1].connect(f); } filters[filters.length - 1].connect(output); const wet = fxCtx.createGain(); wet.gain.value = 0.5; output.connect(wet); wet.connect(fxMasterGain); return { input, output, filters, wet }; }
function createChop() { if (!fxCtx) return null; const g = fxCtx.createGain(), lfo = fxCtx.createOscillator(), lfoGain = fxCtx.createGain(); lfo.frequency.value = 8; lfoGain.gain.value = 0.9; lfo.connect(lfoGain); lfoGain.connect(g.gain); g.connect(fxMasterGain); lfo.start(); return { chopper: g, lfo, lfoGain }; }
function triggerEffect(type) { if (!fxCtx) { console.warn('FX not available'); return; } const osc = fxCtx.createOscillator(), gain = fxCtx.createGain(); osc.frequency.value = 440; gain.gain.value = 0.1; osc.connect(gain); let fx = null; switch (type) { case 'echo': fx = createEcho(); break; case 'reverb': fx = createReverb(); break; case 'filter': fx = createFilter(); break; case 'flanger': fx = createFlanger(); break; case 'distort': fx = createDistortion(); break; case 'gate': fx = createGate(); break; case 'phaser': fx = createPhaser(); break; case 'chop': fx = createChop(); break; } if (fx) gain.connect(fx.delay || fx.convolver || fx.filter || fx.waveshaper || fx.gate || fx.input || fx.chopper); else gain.connect(fxMasterGain); osc.start(); gain.gain.exponentialRampToValueAtTime(0.01, fxCtx.currentTime + 0.5); osc.stop(fxCtx.currentTime + 0.5); console.log(`Triggered ${type} effect`); }

/* YT API identical */
const tag = document.createElement('script'); tag.src = 'https://www.youtube.com/iframe_api'; document.head.appendChild(tag);
window.onYouTubeIframeAPIReady = () => {
  ytPlayer1 = new YT.Player('player1', { videoId: videoId1, width: '100%', height: '100%', playerVars: { autoplay: 0, controls: 1, rel: 0, showinfo: 0 }, events: { onReady: onPlayer1Ready, onStateChange: onPlayer1StateChange } });
  ytPlayer2 = new YT.Player('player2', { videoId: videoId2, width: '100%', height: '100%', playerVars: { autoplay: 0, controls: 1, rel: 0, showinfo: 0 }, events: { onReady: onPlayer2Ready, onStateChange: onPlayer2StateChange } });
};
function onPlayer1Ready() { const c = $('waveCanvas1'); buildRandomPeaks(c); hookAudio(c, ytPlayer1, 1); setupTurntableInteraction(1); startLoop(c, ytPlayer1, '#0f0', false, 1); if (autoMixEnabled) startAutoMixMonitoring(); }
function onPlayer2Ready() { const c = $('waveCanvas2'); buildRandomPeaks(c); hookAudio(c, ytPlayer2, 2); setupTurntableInteraction(2); startLoop(c, ytPlayer2, '#00aaff', true, 2); }
function onPlayer1StateChange() { updateTurntable(1, safeIsPlaying(ytPlayer1)); }
function onPlayer2StateChange() { updateTurntable(2, safeIsPlaying(ytPlayer2)); }

/* time-code identical */
function formatTime(s) { const m = Math.floor(s / 60), sec = Math.floor(s % 60); return `${m}:${sec.toString().padStart(2, '0')}`; }

/* NEW: Update timecodes including turntable displays */
function updateTimeCodes() { 
  const time1 = safeGetCurrentTime(ytPlayer1);
  const time2 = safeGetCurrentTime(ytPlayer2);
  const rem1 = Math.max(0, safeGetDuration(ytPlayer1) - time1);
  const rem2 = Math.max(0, safeGetDuration(ytPlayer2) - time2);
  
  // Update top strip times (remaining time)
  $('deck1Time').textContent = formatTime(rem1);
  $('deck2Time').textContent = formatTime(rem2);
  
  // Update turntable timecodes (elapsed time)
  $('timecode1').textContent = formatTime(time1);
  $('timecode2').textContent = formatTime(time2);
  
  // Update progress rings
  updateProgressRing(1);
  updateProgressRing(2);
}

/* NEW: Update progress ring */
function updateProgressRing(deckNum) {
  const player = deckNum === 1 ? ytPlayer1 : ytPlayer2;
  const ring = $(`progressRing${deckNum}`);
  if (!player || !ring) return;
  
  const dur = safeGetDuration(player);
  const time = safeGetCurrentTime(player);
  
  if (dur > 0) {
    const progress = time / dur;
    const circumference = 2 * Math.PI * 46; // r=46
    const offset = circumference - (progress * circumference);
    ring.style.strokeDashoffset = offset;
  }
}

/* peaks / waveform identical */
function buildRandomPeaks(canv) { const len = canv.width; canv.peaks = new Array(len); for (let i = 0; i < len; i++) canv.peaks[i] = Math.random() * 0.6 + 0.2; }
function buildPeaks(canv) { const len = canv.width; canv.peaks = new Array(len).fill(0); let idx = 0; function grab() { if (idx >= len) return; if (canv.analyser && canv.dataArray) { canv.analyser.getByteFrequencyData(canv.dataArray); canv.peaks[idx] = Math.max(...canv.dataArray) / 255; } idx++; requestAnimationFrame(grab); } grab(); }
function drawWaveform(canv, pct, colourFill, reverse = false) { const ctx = canv.getContext('2d'), dpr = window.devicePixelRatio || 1, displayWidth = canv.clientWidth, displayHeight = canv.clientHeight; ctx.clearRect(0, 0, canv.width, canv.height); if (!canv.peaks || canv.peaks.length === 0) return; const centerY = displayHeight / 2, offset = pct * canv.peaks.length, played = Math.floor(pct * displayWidth); /* outline */ ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 1.5; ctx.beginPath(); for (let x = 0; x < displayWidth; x++) { const idx = offset + x, idxL = Math.floor(idx) % canv.peaks.length, idxR = (idxL + 1) % canv.peaks.length, frac = idx - Math.floor(idx), h = canv.peaks[idxL] * (1 - frac) + canv.peaks[idxR] * frac, yTop = centerY - h * centerY * 0.8, drawX = reverse ? displayWidth - x : x; if (x === 0) ctx.moveTo(drawX + 0.5, yTop); else ctx.lineTo(drawX + 0.5, yTop); } for (let x = displayWidth - 1; x >= 0; x--) { const idx = offset + x, idxL = Math.floor(idx) % canv.peaks.length, idxR = (idxL + 1) % canv.peaks.length, frac = idx - Math.floor(idx), h = canv.peaks[idxL] * (1 - frac) + canv.peaks[idxR] * frac, yBot = centerY + h * centerY * 0.8, drawX = reverse ? displayWidth - x : x; ctx.lineTo(drawX + 0.5, yBot); } ctx.closePath(); ctx.stroke(); /* filled */ ctx.fillStyle = colourFill; ctx.shadowColor = colourFill + '60'; ctx.shadowBlur = 4; ctx.beginPath(); for (let x = 0; x < played; x++) { const idx = offset + x, idxL = Math.floor(idx) % canv.peaks.length, idxR = (idxL + 1) % canv.peaks.length, frac = idx - Math.floor(idx), h = canv.peaks[idxL] * (1 - frac) + canv.peaks[idxR] * frac, yTop = centerY - h * centerY * 0.8, drawX = reverse ? displayWidth - x : x; if (x === 0) ctx.moveTo(drawX + 0.5, centerY); else ctx.lineTo(drawX + 0.5, yTop); } const finalX = reverse ? displayWidth - played : played; ctx.lineTo(finalX, centerY); ctx.closePath(); ctx.fill(); ctx.beginPath(); for (let x = 0; x < played; x++) { const idx = offset + x, idxL = Math.floor(idx) % canv.peaks.length, idxR = (idxL + 1) % canv.peaks.length, frac = idx - Math.floor(idx), h = canv.peaks[idxL] * (1 - frac) + canv.peaks[idxR] * frac, yBot = centerY + h * centerY * 0.8, drawX = reverse ? displayWidth - x : x; if (x === 0) ctx.moveTo(drawX + 0.5, centerY); else ctx.lineTo(drawX + 0.5, yBot); } ctx.lineTo(finalX, centerY); ctx.closePath(); ctx.fill(); ctx.shadowColor = 'transparent'; /* playhead */ ctx.fillStyle = '#fff'; ctx.fillRect(finalX - 0.5, 0, 1, displayHeight); }
function startLoop(canv, player, colourFill, reverse = false, deckNum) { function loop() { const dur = safeGetDuration(player), time = safeGetCurrentTime(player); if (dur > 0 && time >= 0) { const pct = time / dur; drawWaveform(canv, pct, colourFill, reverse); updateTimeCodes(); if (!scratchState[deckNum].dragging) { turntableStates[deckNum].rotation = (time / dur) * 360; $(`turntable${deckNum}`).style.transform = `rotate(${turntableStates[deckNum].rotation}deg)`; } updateTurntable(deckNum, safeIsPlaying(player)); const d = cueLoopData[deckNum]; if (d.loopActive && d.loopIn && d.loopOut && time >= d.loopOut) safeSeek(player, d.loopIn); } if (!isResizing) requestAnimationFrame(loop); } loop(); }
function hookAudio(canv, player, deckNum) { if (!masterCtx) { buildRandomPeaks(canv); return; } const an = masterCtx.createAnalyser(); an.fftSize = 2048; const data = new Uint8Array(an.frequencyBinCount); canv.analyser = an; canv.dataArray = data; setTimeout(() => { try { const vid = player.getIframe().contentWindow.document.querySelector('video'); if (!vid) throw new Error('Video element not found'); const src = masterCtx.createMediaElementSource(vid); src.connect(masterEQFilters.low); masterEQFilters.low.connect(masterEQFilters.mid); masterEQFilters.mid.connect(masterEQFilters.high); masterEQFilters.high.connect(an); an.connect(masterCtx.destination); } catch (e) { buildRandomPeaks(canv); } }, 500); }

/* turntable visual only */
function updateTurntable(deckNum, playing) { const t = $(`turntable${deckNum}`); if (playing && !scratchState[deckNum].dragging) t.classList.add('playing'); else t.classList.remove('playing'); }

/* initResize identical */
function initResize() { requestAnimationFrame(() => { const dpr = window.devicePixelRatio || 1; ['waveCanvas1', 'waveCanvas2'].forEach(id => { const c = $(id), r = c.getBoundingClientRect(), w = r.width, h = r.height; c.width = Math.round(w * dpr); c.height = Math.round(h * dpr); c.style.width = w + 'px'; c.style.height = h + 'px'; c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0); buildRandomPeaks(c); drawWaveform(c, 0, id === 'waveCanvas1' ? '#0f0' : '#f00', id === 'waveCanvas2'); }); }); }


/////
var ytplayer1_playing;
var ytplayer2_playing;
/* ==========  BUTTON HOOKS (unchanged)  ========== */
$('playBtn1').addEventListener('pointerdown', () => { if (ytPlayer1) safeIsPlaying(ytPlayer1) ? ytPlayer1.pauseVideo() : ytPlayer1.playVideo();  ytplayer1_playing=1; ytplayer2_playing=0; console.log("deck1"+ytplayer1_playing); console.log("deck2"+ytplayer2_playing)});
$('playBtn2').addEventListener('pointerdown', () => { if (ytPlayer2) safeIsPlaying(ytPlayer2) ? ytPlayer2.pauseVideo() : ytPlayer2.playVideo(); ytplayer2_playing=1; ytplayer1_playing=0; console.log("deck2"+ytplayer2_playing); console.log("deck1"+ytplayer1_playing)});
//$('autoMixLeft').addEventListener('pointerdown', () => autoFadeTo(0, 2000))
//$('autoMixRight').addEventListener('pointerdown', () => autoFadeTo(1, 2000))
//updated to add background play
$('autoMixLeft').addEventListener('pointerdown',function() { autoFadeTo(0, 2000); ytplayer1_playing=1; ytplayer2_playing=0;  });
$('autoMixRight').addEventListener('pointerdown',function() { autoFadeTo(1, 2000); ytplayer1_playing=0; ytplayer2_playing=1;  });
/* cue */
$('cue1Set').addEventListener('pointerdown', () => setCuePoint(1));
$('cue1Jump').addEventListener('pointerdown', () => jumpToCuePoint(1));
$('loop1In').addEventListener('pointerdown', () => setLoopIn(1));
$('loop1Out').addEventListener('pointerdown', () => setLoopOut(1));
$('loop1Active').addEventListener('pointerdown', () => toggleLoop(1));
$('cue1Clear').addEventListener('pointerdown', () => clearCueLoop(1));
$('cue2Set').addEventListener('pointerdown', () => setCuePoint(2));
$('cue2Jump').addEventListener('pointerdown', () => jumpToCuePoint(2));
$('loop2In').addEventListener('pointerdown', () => setLoopIn(2));
$('loop2Out').addEventListener('pointerdown', () => setLoopOut(2));
$('loop2Active').addEventListener('pointerdown', () => toggleLoop(2));
$('cue2Clear').addEventListener('pointerdown', () => clearCueLoop(2));
/* loop length */
document.querySelectorAll('.loop-length-btn').forEach(b => b.addEventListener('pointerdown', () => setAutoLoopLength(parseInt(b.dataset.deck), parseInt(b.dataset.length))));
/* auto-mix */
$('autoMixToggle').addEventListener('pointerdown', toggleAutoMix);
$('nextTrackBtn').addEventListener('pointerdown', manualNextTrack);
/* playlist */
$('assignDeck1').addEventListener('pointerdown', () => {currentAssignment = 1; updateAssignmentButtons(); });
$('assignDeck2').addEventListener('pointerdown', () => {currentAssignment = 2; updateAssignmentButtons(); });
$('addTrackBtn').addEventListener('pointerdown', addNewTrack);
/* BPM */
$('tapTempo1').addEventListener('pointerdown', () => tapTempo(1));
$('tapTempo2').addEventListener('pointerdown', () => tapTempo(2));
$('syncBPM').addEventListener('pointerdown', syncBPM);
$('resetBPM').addEventListener('pointerdown', resetBPM);
/* FX */
['Echo', 'Reverb', 'Filter', 'Flanger', 'Distort', 'Gate', 'Phaser', 'Chop'].forEach(fx => $('fx' + fx).addEventListener('pointerdown', () => triggerEffect(fx.toLowerCase())));

/* NEW: Playlist track toggle button */
$('playlistTrackToggle').addEventListener('pointerdown', togglePlaylistTracks);

/* ==========  DOM READY  ========== */
document.addEventListener('DOMContentLoaded', () => {
  /* audio context */
  try {
    masterCtx = new (window.AudioContext || window.webkitAudioContext)();
    for (const [band, setting] of Object.entries(EQ_SETTINGS)) {
      const f = masterCtx.createBiquadFilter();
      f.type = setting.type;
      f.frequency.value = setting.freq;
      f.gain.value = 0;
      f.Q.value = 1;
      masterEQFilters[band] = f;
    }
    initSoundEffects();
  } catch (e) { console.warn('Web Audio API not available:', e); masterCtx = null; }
  centerCrossfader();
  updateBPMDisplay();
  //renderPlaylist();
  updateAssignmentButtons();
  document.querySelectorAll('.loop-length-btn[data-deck="1"][data-length="8"]').forEach(b => b.classList.add('active'));
  document.querySelectorAll('.loop-length-btn[data-deck="2"][data-length="8"]').forEach(b => b.classList.add('active'));
  initResize();
  addMasterEQControls();
  setupCrossfader();
  addSeparateTouchControls();
  
  /* Initialize playlist search */
  $('playlistSearch').addEventListener('input', filterPlaylist);
});


///////////background play test 
document.addEventListener("visibilitychange", () => { if (document.hidden) { setTimeout(function () { if (ytplayer1_playing===1) {ytplayer2_playing=0;  ytPlayer1.playVideo(); } }, 500); } else {ytplayer2_playing=1;ytPlayer2.playVideo()}});

document.addEventListener("visibilitychange", () => { if (document.hidden) { setTimeout(function () { if (ytplayer2_playing===1) {ytplayer1_playing=0;  ytPlayer2.playVideo();} }, 500); } else {}});

//document.addEventListener("visibilitychange", () => { if (document.hidden) { setTimeout(function () { if (ytPlayer2) { ytPlayer2.playVideo();} }, 500); } else {ytPlayer1.playVideo()}});


////////////////



</script>
</body>
</html>